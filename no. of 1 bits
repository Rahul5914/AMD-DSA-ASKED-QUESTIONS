Perfect ğŸ‘Œ â€” this is one of the most famous bit manipulation tricks in programming interviews, known as Brian Kernighanâ€™s Algorithm for counting set bits (i.e., the number of 1s in the binary representation of a number).

Weâ€™ll go line by line, explain whatâ€™s happening inside the bits, and show why this trick is much faster than the naÃ¯ve approach.

ğŸ§© Problem: Count the Number of 1s (Set Bits) in a Number

For example:

Input:  13
Binary: 1101
Output: 3  (because there are 3 ones)

ğŸ’» Code (Given)
int countSetBits(int number) {
    int bitCount = 0;

    while (number) {
        number &= (number - 1);
        bitCount++;
    }

    return bitCount;
}

ğŸ§  Step-by-Step Deep Explanation
ğŸ”¹ Line 1:
int bitCount = 0;


We initialize a counter variable to count how many 1s (set bits) we find.

ğŸ”¹ Line 2:
while (number) {


This means:

Keep looping as long as the number is not zero.

Once number becomes 0, it means there are no set bits left.

ğŸ”¹ Line 3 (ğŸ”¥ The Key Line):
number &= (number - 1);


Letâ€™s break this down â€” this is the heart of the algorithm.

âš™ï¸ What Does number &= (number - 1) Do?

This line:

number = number & (number - 1);


removes the rightmost (least significant) set bit (1) from the number.

ğŸ” Letâ€™s visualize this with an example:

Letâ€™s take:

number = 13
Binary: 1101


Now, letâ€™s calculate (number - 1):

number      = 1101
(number-1)  = 1100


Now perform the bitwise AND:

1101   (13)
1100   (12)
---- &
1100   (12)


Result = 1100

âœ… Effect: The rightmost set bit (last 1) has been cleared.

Now again, next iteration:

number = 1100
(number - 1) = 1011
AND result = 1000


âœ… The next rightmost 1 cleared.

Next iteration:

number = 1000
(number - 1) = 0111
AND result = 0000


âœ… Now all bits cleared â†’ loop stops.

ğŸ”¹ Line 4:
bitCount++;


Every time we clear one bit, we increase the count by one, because weâ€™ve found (and removed) one set bit.

ğŸ”¹ Line 5:
return bitCount;


After all bits are cleared, bitCount stores how many set bits were found.

ğŸ§® Dry Run Example: number = 13
Step	number (binary)	number-1 (binary)	AND Result	bitCount
1	1101	1100	1100	1
2	1100	1011	1000	2
3	1000	0111	0000	3

Loop stops (number = 0)
âœ… Final bitCount = 3.

ğŸ”¥ Why Is This Faster Than Normal Bit Checking?
NaÃ¯ve method:

Check every bit:

while (number > 0) {
    if (number & 1)
        bitCount++;
    number >>= 1;
}


This checks all bits, even if theyâ€™re 0 â†’ O(total bits) (â‰ˆ 32 iterations for 32-bit int).

Brian Kernighanâ€™s method:

Loops only for the number of 1s â†’
O(number of set bits) â© Much faster for sparse numbers.

For example:

number = 8 (binary 1000) â†’ only 1 iteration.

number = 1,073,741,824 (2Â³â°) â†’ only 1 iteration.

number = 15 (1111) â†’ 4 iterations.

ğŸ§  Logic Summary

Each iteration:

Removes one set bit.

Increments the counter.

Mathematically, for k set bits in n,
the loop runs exactly k times.

Formula logic:

n = n & (n - 1)
âŸ¹ removes lowest set bit

ğŸ§© Example Visualization

Letâ€™s visualize with n = 22 (10110):

Iteration	Binary (before)	Binary (after n & (n-1))	bitCount
1	10110	10100	1
2	10100	10000	2
3	10000	00000	3

âœ… Final result: bitCount = 3

â±ï¸ Complexity
Type	Complexity
Time	O(k), where k = number of set bits
Space	O(1)
ğŸ§© Pattern Recognition (Interview Tip)

This trick (n & (n-1)) appears in many bit manipulation problems, such as:

Checking power of two:
if (n && !(n & (n - 1))) â†’ true if only one bit is set.

Counting set bits (current one).

Removing last set bit in bitmask DP problems.

So, whenever you see bit clearing or â€œpower of twoâ€ checks, this pattern is likely involved.

âœ… Final Code (clean)
int countSetBits(int number) {
    int bitCount = 0;
    while (number) {
        number &= (number - 1); // clear the rightmost 1
        bitCount++;
    }
    return bitCount;
}
